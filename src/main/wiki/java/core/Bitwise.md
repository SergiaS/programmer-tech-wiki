# Bitwise

__LINKS:__
* [Побитовые операции - JavaRush](https://javarush.ru/groups/posts/1925-pobitovihe-operacii)
* [Побитовое отрицание — почему так](https://javarush.ru/groups/posts/3148-pobitovoe-otricanie---pochemu-tak)

Любое число в **Java** можно сконвертировать в его двоичную форму. 
Для этого нужно использовать классы-обертки:
```java
// конвертація з десятирічної (десяткової) форми у бінарну (двійкову):
int x = 342;
System.out.println(Integer.toBinaryString(x));  // 101010110

// конвертація з бінарної форми у десятирічну:
System.out.println(Integer.parseInt("101010110", 2)); // 342
```

***


`~` — побитовый оператор “НЕ”, называемый также побитовым дополнением. 

Работает очень просто: проходится по каждому биту нашего числа и меняет его значение на противоположное: нули — на единицы, единицы — на нули.

Но интересно то, что результат будет неожиданностью, например:
```java
int a = 342;
System.out.println(Integer.toBinaryString(a));
// 101010110
System.out.println(Integer.toBinaryString(~a));
// 11111111111111111111111010101001
```
Всё дело в том, что в переменной не может лежать просто 101010110, на самом деле оно хранится как
00000000000000000000000101010110. Ведь переменная типа int занимает 4 байта, т.е. 32 бита — 32 ячейки памяти.

__Самое интересное:__ Так как в бинарном представлении знак `+` или `-` перед числом сохранить не получается, то существует одна хитрость: самый 1й бит на самом деле отвечает за знак и как раз является тем самым знаковым разрядом. А все числа хранятся по такой логике:

Числа от 00...000 до 01...111 — положительные, начинающиеся с 0 (т.е. от 0 до 2147483647), а начиная с 10...000 до 11...111 — это отрицательные, начиная с самого минимального и заканчивая -1 (т.е. от -2147483648 до -1).

Для большего понимания читай [Побитовое отрицание — почему так](https://javarush.ru/groups/posts/3148-pobitovoe-otricanie---pochemu-tak)


***


`&` — побитовый оператор “И”.

Сравнивает два числа по битам.
Результатом этого сравнения является третье число.


***


`^` — побитовое исключающее “ИЛИ” (также известно как `XOR`). 

Похож на обычное “или”. Разница в одном: обычное “или” возвращает `true`, если хотя бы один операнд является истинным. 
Но не обязательно один — если оба будут `true` — то и результат `true`.

```java
100010101
^
110110000
_________
010100101 — результат работы ^
```
Те биты, которые были в обоих числах одинаковыми, вернули 0 (не сработала формула “один из”).
А вот те, которые образовывали пару 0-1 или 1-0, в итоге превратились в единицу.


## Bitwise shift (Побітовий зсув) 
> Операція, яка зсуває біти в бітовому представленні числа вправо або вліво.

> Для побітового зсуву вправо використовується оператор `>>`, для побітового зсуву вліво - оператор `<<`.
>
> При побітовому зсуві вправо, біти числа зсуваються вправо на задану кількість позицій, і вільні біти в лівій частині заповнюються нулями. 
> При побітовому зсуві вліво, біти числа зсуваються вліво на задану кількість позицій, і вільні біти в правій частині заповнюються нулями.

> Побітовий зсув використовується для ефективної реалізації операцій множення та ділення на степінь двійки. 
> Наприклад, <u>**зсув на одну позицію вправо відповідає діленню числа на 2, а зсув на одну позицію вліво відповідає множенню числа на 2.**</u>
> 
> |      | Приклад побітового зсуву | Результат | Значення   |
> |:-----|:-------------------------|:----------|:-----------|
> | `<<` | `10 << 1`                | `20`      | `10 * 2`   |
> |      | `10 << 2`                | `40`      | `10 * 4`   |
> |      | `10 << 3`                | `80`      | `10 * 8`   |
> |      | `10 << 4`                | `160`     | `10 * 16`  |
> |      | `10 << 5`                | `320`     | `10 * 32`  |
> | `>>` | `100 >> 1`               | `50`      | `100 / 2`  |
> |      | `100 >> 2`               | `25`      | `100 / 4`  |
> |      | `100 >> 3`               | `~12`     | `100 / 8`  |
> |      | `100 >> 4`               | `~6`      | `100 / 16` |
> |      | `100 >> 5`               | `~3`      | `100 / 32` |


> Операції побітового зсуву швидкі та ефективні, оскільки вони працюють безпосередньо з бітами числа. 
> Однак, варто пам'ятати, що при побітовому зсуві вправо, знакові біти можуть втратитись, 
> що може призвести до неправильних результатів в окремих випадках.
