# Collections framework
Коллекции в Java перед тем как сравнить объекты с помощью `equals` всегда ищут/сравнивают их с помощью метода `hashCode`.
И если у одинаковых объектов будут разные `hashCode`, то объекты будут считаться разными — до сравнения с помощью `equals` просто не дойдет.


<hr>

## List
```java
List<String> list = new ArrayList<>(List.of("Ted","Bob","Lex","Liza","Tasha"));
```

Примеры с двойными фигурными скобками `{{}}` означают сначало анонимный класс, и потом блок инициализации.
```java
List<String> list = new ArrayList<>() {{
    add("Ted");
    add("Bob");
    add("Lex");
    add("Liza");
    add("Tasha");
}};
```

```java
public static void main(String[] args) {
    calc(new ArrayList<>(){{add("2");}});
}

private static void calc(List<String> list) {
    System.out.println(list); // 2
}
```

## Map interface
```java
Map<String, PersonEmpl> map = new HashMap<>() {{
    put("IT", new PersonEmpl("Ted", 34));
    put("Market", new PersonEmpl("Liza", 27));
    put("Admin", new PersonEmpl("Carl", 30));
}};
```


### Принцип работы HashMap
[How HashMap works in Java](https://javarevisited.blogspot.com/2011/02/how-hashmap-works-in-java.html?utm_source=dlvr.it&utm_medium=facebook&m=1)

HashMap состоит из «корзин» (bucket`ов). «корзины» — это элементы массива, которые хранят ссылки на списки элементов.

При добавлении новой пары ключ-значение, вычисляет хеш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то он заменяется.

Добавление, поиск и удаление элементов выполняется за константное время. Хеш-функций должны равномерно распределять элементы по корзинам, в этом случае временная сложность для этих 3 операций будет не ниже O(log(n)), а в среднем случае как раз константное время.



### Добавление
Пример добавления в мапу из другой коллекции - подсчет одиннаковых элементов.

```java
Map<Integer, Integer> map = new HashMap<>();
for (int n : array) {
    map.put(n, map.getOrDefault(n, 0) + 1);
}
```
Хорошо подходит для заполнения мапы в цикле, здесь нет необходимости использовать методы `computeIfPresent()`, `putIfAbsent()`...

### Сортировка по значению в обратном порядке
Пример сортировки по значению в обратном порядке через `Comparator` через stream.
```java
// to List
List<Integer> list = map.entrySet().stream()
        .sorted(Entry.<Integer, Integer>comparingByValue().reversed())
        .limit(k)
        .map(Entry::getKey)
        .collect(Collectors.toList());
```

```java
// to int[] array
int[] arr = map.entrySet().stream()
        .sorted(Entry.<Integer, Integer>comparingByValue().reversed())
        .limit(k)
        .map(Entry::getKey)
        .mapToInt(i -> i)
        .toArray();
```

### [Пример сортировки HashMap](https://mishrasuraj.medium.com/sorting-hashmap-in-java-8-6fadc1cacb2b)
```java
Map<String, PersonEmpl> map = new HashMap<>() {{
    put("JAVA", new PersonEmpl("Ted", 34));
    put("Perl", new PersonEmpl("Liza", 27));
    put("Python", new PersonEmpl("Carl", 30));
    put("C++", new PersonEmpl("Zina", 33));
    put("C#", new PersonEmpl("Tomas", 41));
    put("GO", new PersonEmpl("Lucas", 31));
    put("Ruby", new PersonEmpl("Sam", 24));
    put("Scala", new PersonEmpl("Simona", 29));
    put("JS", new PersonEmpl("Andy", 32));
    put("C", new PersonEmpl("Sara", 29));
}};
```

Sort by name - declarative:
```java
List<Map.Entry<String, PersonEmpl>> mapEmpl = new ArrayList<>(map.entrySet());
Collections.sort(mapEmpl, (a,b) -> a.getValue().getName().compareTo(b.getValue().getName()));
mapEmpl.forEach(System.out::println);
```

Provide a sorting logic as lambda function:
```java
map.entrySet().stream()
        .sorted((a,b) -> a.getValue().getName().compareTo(b.getValue().getName()))
        .forEach(System.out::println);
```

### Interview questions
<hr>

Q: __Какова роль `equals` и `hashCode` в `HashMap`?__
    
A: `hashCode` позволяет определить корзину для поиска элемента, а `equals` используется для сравнения ключей элементов в списке внутри корзины и искомого ключа.

<hr>

Q: __Как и когда происходит увеличение количества корзин в HashMap?__

A: Помимо `capacity` в HashMap есть еще параметр `loadFactor`, на основании которого, вычисляется предельное количество занятых корзин (`capacity * loadFactor`). 
По умолчанию `loadFactor = 0,75`. По достижению предельного значения, число корзин увеличивается в 2 раза. Для всех хранимых элементов вычисляется новое «местоположение» с учетом нового числа корзин.

<hr>

Q: __Почему нельзя использовать массивы в качестве ключа в HashMap?__

A: Потому что хеш-код массива вычисляется при его создании и не зависит от кол-ва элемента в нем (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному `Object.hashCode` на основании адреса массива).

Так же у массивов не переопределен `equals` и выполняется сравнение указателей. 
Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.

<hr>

Q: __Сколько переходов происходит в момент вызова `HashMap.get(key)` по ключу, который есть в таблице?__

A: Если ключ равен `null`: 1 - выполняется единственный метод `getForNullKey()`.
   Любой ключ отличный от `null`: 4 - вычисление хэш-кода ключа; определение номера корзины; поиск значения; возврат значения.

<hr>

Q: __Сколько создается новых объектов, когда вы добавляете новый элемент в HashMap?__

A: Один новый объект статического вложенного класса `Entry<K,V>`.

<hr>

Q: __Зачем нужен HashMap, если есть HashTable?__

A: HashTable - это устаревший класс и его использование не рекомендовано.

- Методы класса HashTable синхронизированы, что приводит к снижению производительности, а HashMap - нет;
- HashTable не может содержать элементы `null`, тогда как HashMap может содержать один ключ `null` и любое количество значений `null`;
- `Iterator` у HashMap, в отличие от `Enumeration` у HashTable, работает по принципу `fail-fast` (выдает исключение при любой несогласованности данных).

<hr>

Q: __Какое начальное количество корзин в HashMap?__

A: По умолчанию 16. Используя конструкторы с параметрами можно задавать свое начальное количество корзин.



## Queue
Отличительная особенность данной коллекции - Очереди обычно, но не обязательно, упорядочивают элементы в `FIFO` (First-In-First-Out). 
Реализации: однонаправленная очередь `PriorityQueue`, двунаправленная очередь `ArrayDeque` и связаной список `LinkedList`.

### PriorityQueue
Особенностью `PriorityQueue` является возможность управления порядком элементов. 
По-умолчанию, элементы сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта `Comparator`, который задаётся при создании очереди.
- Не поддерживает `null`-значения и non-comparable объекты.
- Размер неограничен, можно задать при создании - увеличивается автоматически.
- Не является потобезопасной! Для этих целей в Java реализован класс `PriorityBlockingQueue`.
- Добавление/удаление элементов происходит за время `O(log(n))`.
- `PriorityQueue.toString` использует `iterator()`, который не гарантирует прохождение элементов приоритетной очереди в каком-либо определенном порядке.

### ArrayDeque
Представляет собой реализацию с использованием массивов, подобно `ArrayList`, но не позволяет обращаться к элементам по индексу и хранение `null`.
`ArrayDeque` реализует интерфейс Deque и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, либо как стек, действующий по принципу `LIFO` (последний вошел - первый вышел).
> DOC: Коллекция работает быстрее чем Stack, если используется как LIFO коллекция, а также быстрее чем LinkedList, если используется как FIFO.
- Методы позволяют обращаться как к голове, так и к хвосту: `addFirst`/`addLast`, `getFirst`/`getLast`, `offerFirst`/`offerLast`...

### LinkedList
Класс `LinkedList` реализует два интерфейса - `List` и `Deque`.
В основе лежит двунаправленный связный список, где каждый элемент имеет ссылку на предыдущий и следующий элементы. 
По этим ссылкам можно переходить от одного элемента к другому. При добавлении элемента просто меняются ссылки на предыдущий и следующий элементы. 
Также, ввиду реализации, данную коллекцию можно использовать как стек или очередь.
Добавление и удаление из середины, доступ по индексу, значению происходит за линейное время `O(n)`, а из начала и конца за константное `O(1)`.
