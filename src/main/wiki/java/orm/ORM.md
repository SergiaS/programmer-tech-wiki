# ORM
* [Аннотации Java для работы с базой данных](https://javastudy.ru/spring-data-jpa/annotation-persistence/)

> **У сущностей переопределять `equals()` и `hashcode()` можно только на основе не изменяемых полей, например, если у объекта TO (transfer object).**

> ORM состоит из:
> * API, который реализует базовые операции (СОЗДАНИЕ, ЧТЕНИЕ,  ИЗМЕНЕНИЕ, УДАЛЕНИЕ) объектов-моделей.
> * Средства настройки метаданных связывания
> * Технику взаимодействия с транзакциями, которая позволяет реализовать такие функции, как dirty checking, lazy association fetching и т.д.

> Инфраструктурам ORM требуются транзакции для синхронизации содержимого кэша объектов и базы данных.

> Все ORM и JPA реализованы поверх JDBC.

> Нельзя объекты сравнивать через equals() and hashCode() в бизнес-логике (например, тестах).
> 
> [Source](https://stackoverflow.com/questions/1638723/how-should-equals-and-hashcode-be-implemented-when-using-jpa-and-hibernate)

> Какие бывают транзакционные модели?
> 1. Local — голый JDBC
> 2. Programmatic — JPA
> 3. Declarative — Spring (когда мы ставим аннотацию)

> Какие преимущества нам даёт ORM в сравнение с JDBC?
> * Позволяет нашим бизнес-методам обращаться не к БД, а к Java-классам
> * Ускоряет разработку приложения
> * Основан на JDBC
> * Отделяет SQL-запросы от ОО модели
> * Позволяет не думать о реализации БД
> * Сущности основаны на бизнес-задачах, а не на структуре БД
> * Управление транзакциями





## Требования к POJO классам
Сущесвуют определённые требования к POJO классам. Вот самые главные из них:
> Все классы должны иметь `id` для простой идентификации наших объектов в БД и в __Hibernate__. Это поле класса соединяется с первичным ключём (`primary key`) таблицы БД.
> Все POJO – классы должны иметь конструктор по умолчанию (пустой).
> Все поля POJO – классов должны иметь модификатор доступа `private` иметь набор `getter`-ов и `setter`-ов в стиле __JavaBean__.
> POJO – классы не должны содержать бизнес-логику.

Мы называем классы POJO для того, чтобы подчеркнуть тот факт, что эти объекты являются экземплярами обычных Java-классов.


## Проблема [N+1](https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping)
* [What is the "N+1 selects problem" in ORM?](https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping)

Проблема N + 1 возникает, когда выполняется N дополнительных SQL-запросов для получения тех же данных, которые можно 
получить при выполнении одного SQL-запроса. 
Чем больше значение N, тем больше запросов будет выполнено и тем больше влияние на производительность. 
Например, в нашем случае при получении списка пользователей сначала будут загружены все пользователи, и затем для 
каждого пользователя будет выполнен запрос в базу для получения его ролей. 
Таким образом, если бы у нас было 1000 пользователей, то будет выполнен 1 запрос для получения всех пользователей и 
дополнительно 1000 запросов для получения ролей каждого пользователя, итого 1000 + 1 запрос.

__Некоторые способы решения проблемы N+1:__
1. Получать сущность из базы данных через запрос с использованием `JOIN FETCH` - в таком случае таблицы будут 
объединяться на уровне БД и вся информация будет получена сразу.
2. Пометить коллекцию сущности, для получения которой выполняются дополнительные запросы, аннотацией `@Fetch(FetchMode.SUBSELECT)`. 
В этом случае, сначала будет загружена коллекция пользователей и затем будет выполнен один дополнительный запрос, 
который получит роли всех этих пользователей.
3. Пометить коллекцию аннотацией `@BatchSize(size = 200)` - в данном случае сначала будет выполнен запрос на получение 
всех пользователей, и затем дополнительными запросами будут загружаться > роли этих пользователей — 
по 200 пользователей за запрос.
4. JPA 2.1 предоставляет для решения этой проблемы функциональность `@EntityGraph` - на уровне сущности мы можем 
объявить граф полей, которые будут загружаться > из базы данных совместно с сущностью. 
При определении последующих запросов мы можем указать наименование нужного нам __Entity Graph__, и JPA сформирует 
запрос в соответствии с этим графом и загрузит только описанные в нем поля. `@EntityGraph` можно определять не только 
на уровне сущности, это можно сделать непосредственно в интерфейсе через параметр аннотации attributePath, 
например: `@EntityGraph(attributePaths = {"meals", "roles"})`


## Comparing table

|Object           | JPA                  | Hibernate        | JDBC         |
|:-------         |:--------             |:-------          |:--------     |
|Фабрика сессий   | EntityManagerFactory | SessionFactory   | DataSource   |
|                 | EntityManager        | Session          | Connection   |
