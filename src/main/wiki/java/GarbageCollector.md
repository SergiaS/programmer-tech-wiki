# Garbage Collector
* [Garbage Collector — An Introduction](https://medium.com/javarevisited/garbage-collection-an-introduction-169922e90c61)
![img](https://miro.medium.com/max/770/1*JJClvb9nwTiIvDy7bmsqOg.png)

> Скільки і які саме збирачі сміття є у Java - залежить від версії Java (8, 11, 17...) і для якої платформи (Linux x64, Windows x64...).

***

* [Oracle - Why Does the Choice of Garbage Collector Matter?](https://docs.oracle.com/en/java/javase/17/gctuning/introduction-garbage-collection-tuning.html#GUID-A48F272E-A6C1-45A0-9A8B-6D5790EB454C)

***

* [Oracle - Available Collectors in Java 17](https://docs.oracle.com/en/java/javase/17/gctuning/available-collectors.html#GUID-F215A508-9E58-40B4-90A5-74E29BF3BD3C)

1. **Serial Collector**<br>
   Серійний збирач сміття використовує один потік для виконання усієї роботи зі збиранням сміття, що робить його відносно ефективним, 
   оскільки немає накладки комунікації між потоками.

   Він найбільш підходить для однопроцесорних машин, оскільки не може використовувати мультипроцесорний апаратний засіб, 
   хоча може бути корисним на мультипроцесорних системах для додатків з невеликими обсягами даних (до приблизно 100 МБ). 
   Серійний збирач сміття вибирається за замовчуванням на певних конфігураціях апаратного забезпечення та операційних систем, 
   або може бути явно ввімкнений за допомогою опції `-XX:+UseSerialGC`.

2. **Parallel Collector**<br>
   Паралельний збирач також відомий як збирач пропускної здатності, це колектор з моделлю на поколіннях. Він схожий на серійний колектор.
   Основна відмінність між серійним і паралельним збирачами полягає в тому, що паралельний збирач має кілька потоків, які використовуються для прискорення збору сміття.
   
   Паралельний збирач призначений для застосунків з середнього розміру до великого об'єму даних, які працюють на мультипроцесорних або багатопотокових пристроях.
   Ви можете увімкнути його за допомогою опції `-XX:+UseParallelGC`.
   
   Паралельне ущільнення - це функціональність, яка дозволяє паралельному збирачу виконувати головні збірки паралельно.
   Без паралельного ущільнення головні збірки виконуються за допомогою одного потока, що може значно обмежувати масштабованість.
   Паралельне ущільнення ввімкнено за замовчуванням, якщо вказано опцію `-XX:+UseParallelGC`. 
   Ви можете вимкнути його, використовуючи опцію `-XX:-UseParallelOldGC`.

3. **Garbage-First (G1)**<br>
   G1 - це в основному паралельний збирач.
   Паралельні збирачі виконують деяку дороговартісну роботу паралельно з додатком. 
   Цей збирач розроблений для машин з невеликої кількістю пам'яті і великою кількістю процесорів,
   а також для машин з багатою пам'яттю та багатопроцесорними системами. 
   Він забезпечує можливість досягнення певної цілі по часу паузи з високою ймовірністю при високій продуктивності.

   G1 вибирається за замовчуванням на більшості конфігурацій апаратного забезпечення та операційних систем, 
   або може бути явно включений за допомогою `-XX:+UseG1GC`.

4. **Z Garbage Collector**<br>
   Z Garbage Collector (ZGC) - це масштабований збирач сміття з низькою латентністю (малою затримкою).
   ZGC виконує всю дороговартісну роботу паралельно без зупинки виконання потоків додатку.

   ZGC забезпечує максимальні часи пауз всього кілька мілісекунд за рахунок деякого зниження продуктивності. 
   Він призначений для додатків, які потребують низької латентності. 
   Час пауз не залежить від розміру кучі, що використовується.
   ZGC підтримує розміри кучі від 8 МБ до 16 ТБ. 
   Для включення його використовуйте опцію `-XX:+UseZGC`.



***

* [Medium - Сборка мусора в Java: что это такое и как работает в JVM](https://medium.com/nuances-of-programming/сборка-мусора-в-java-что-это-такое-и-как-работает-в-jvm-25bb2570b44c)

Збирач сміття (Garbage Collector) - це автоматичний механізм в Java, що виконується JVM. 
Основна ціль збирача сміття – звільнити пам'ять купи, видаливши об'єкти, на які не має посилань - такий об'єкт вважається мертвим, а отже більше не потрібний.

При збірці сміття об'єкти перевіряються - чи є на них посилання, - на яких немає - видаляються.

Область пам'яті купи JVM розділена на три секції:
- <u>**Молоде покоління (Young Generation):**</u> Створені об'єкти починають свій шлях тут.
  - **Простір Едену (Eden space):** усі нові об'єкти починають тут, і їм виділяється початкова пам'ять.
    > <details>
    > <summary>Приклад роботи простору Eden</summary>
    > 
    > Возьмем в качестве примера следующую последовательность:
    > - В Эдеме есть объекты обоих типов (живые и мертвые).
    > - Происходит малая GC — все мертвые объекты удаляются из Эдена.
    >   Все живые объекты перемещаются в пространство-1 (FromSpace). Эдем и пространство-2 теперь пусты.
    > - Новые объекты создаются и добавляются в Эден. Некоторые объекты в Эдеме и пространстве-1 становятся мертвыми.
    > - Происходит малая GC — все мертвые объекты удаляются из Эдена и пространства-1. Все живые объекты перемещаются в пространство-2 (ToSpace).
    >   Эден и пространство-2 снова пусты.
    >
    > Таким образом, в любое время одно из пространств для выживших всегда пусто. 
    > Когда выжившие объекты достигают определенного порога перемещения по пространствам выживших, они переходят в старшее поколение.
    >
    > Для установки размера молодого поколения можно воспользоваться флагом `-Xmn`.
    >
    > </details>

  - **Простори тих, хто вижив (FromSpace і ToSpace):** об'єкти переміщуються сюди з Едену після того, як пережили один цикл збирання сміття.
    > <details>
    > <summary>Приклад для розуміння просування об'єктів між просторами та поколіннями</summary>
    >
    > Коли об'єкт створюється, він спочатку поміщається у простір **Едену** молодого покоління.
    > Як тільки відбувається малий збирач сміття, живі об'єкти з **Едену** переміщуються в простір **FromSpace**.
    > Коли відбувається наступне малий збирач сміття, живі об'єкти **Едену**, так і з простору переміщуються в простір **ToSpace**.
    >
    > Цей цикл триває кілька разів. Якщо об'єкт все ще "в строю" після цього моменту, наступний цикл збирання сміття перемістить його в простір старшого покоління.
    > </details>
- <u>**Старше покоління (Old Generation), або штатне:**</u> Об'єкти-довгожителі зрештою переходять із молодого покоління до старшого.
  Для встановлення початкового та максимального розміру пам'яті купи можна скористатися прапорами `-Xms` і `-Xmx`.
  Оскільки Java задіює збирач сміття за поколіннями, то чим більше подій збирання сміття переживає об'єкт, тим далі він просунеться в купі.
- <u>**Постійне покоління (Permanent generation):**</u> Метадані, такі як класи та методи, зберігаються у постійному поколінні.
  Класи, які більше не використовуються, можуть переходити із постійного покоління у сміття.
  Для встановлення початкового та максимального розміру постійного покоління можна скористатися прапорами `-XX:PermGen` та `-XX:MaxPermGen`.


У віртуальної машини Java такі збирачі сміття (залежить від версії Java):
> **CMS (Concurrent Mark Sweep Collector)** став застарілим у Java 14, а у Java 17 повністю прибрали. 

1. **Серійний GC (Serial Collector)**. Це найпростіший Garbage Collector, призначений для невеликих додатків, що працюють у однопотокових середовищах.
   Усі події збирання сміття виконуються послідовно в одному потоці.
   Запуск збирача призупиняє роботу програма.
   > Аргумент JVM для використання послідовного збирача сміття `-XX:+UseSerialGC`.
2. **Паралельний GC (Parallel Collector).** На відміну від Serial Garbage Collector, він використовує кілька потоків для управління простором купи, 
   але він також заморожує інші потоки додатків під час виконання GC.
   > Аргумент JVM для використання паралельного збирача сміття: `-XX:+UseParallelGC`.
   
   Якщо ми використовуємо цей GC, ми можемо вказати максимальні нитки для збору сміття та призупинити час, пропускну здатність та розмір купи:
   ```shell
   # The numbers of garbage collector threads:   
   -XX:ParallelGCThreads=<N>
   
   # The maximum pause time goal (gap [in milliseconds] between two GC)
   -XX:MaxGCPauseMillis=<N>
   
   # Час, витрачений на збирання сміття, порівняно з часом, витраченим поза збиранням сміття, називається цільовою максимальною пропускною здатністю
   -XX:GCTimeRatio=<N>
   
   # The maximum heap footprint (the amount of heap memory that a program requires while running)
   -Xmx<N>
   ```
3. **G1 (Garbage First Collector).** Колектор G1 замінив колектор CMS, оскільки він більш ефективний.
   Він є комбінованим збирачем, який виконує збірку у фоновому режимі, розділяючи пам'ять на області і збираючи сміття в окремих областях.
   ```shell
   # To enable the G1 Garbage Collector, we can use the following argument:
   java -XX:+UseG1GC -jar Application.java
   ```
4. **ZGC (Z Garbage Collector).** Призначенний для забезпечення малої затримки (low latency) під час збору сміття великих об'ємів пам'яті.
   У ZGC пам'ять поділяється на області (regions), які можуть бути збирані незалежно одна від одної. Кожна область має фіксований розмір та номер, що дозволяє збирачу легко відслідковувати використання пам'яті та стан областей.
   ZGC має можливість динамічно змінювати розмір пам'яті, що виділяється під збирач сміття, залежно від потреб додатку.
   ```shell
   # To enable the Z Garbage Collector:
   java java -XX:+UseZGC Application.java
   ```