# SQL
* [Сервіс DrawIO - намалювати/створити UML структуру таблиці](https://app.diagrams.net/)


## Нормальные формы

***

* [Описание основных приемов нормализации БД - Microsoft](https://docs.microsoft.com/ru-ru/office/troubleshoot/access/database-normalization-description#first-normal-form)

**Первая нормальная форма:**
* Устраните повторяющиеся группы в отдельных таблицах.
* Создайте отдельную таблицу для каждого набора связанных данных.
* Идентифицируйте каждый набор связанных данных с помощью первичного ключа.

**Вторая нормальная форма:**
* Создайте отдельные таблицы для наборов значений, относящихся к нескольким записям.
* Свяжите эти таблицы с помощью внешнего ключа.

**Третья нормальная форма:**
* Устраните поля, не зависящие от ключа.

***

* [Нормальные формы - YouTube](https://www.youtube.com/watch?v=_GQaTW6N1GY)

### Первая нормальная форма
* **Правило 1**: все элементы внутри ячеек должны быть атомарными (т.е. у каждого столбца своё предназначение - бренд, цвет..., а не 'TV Sony KX40').
Элемент является атомарным, если его нельзя разделить на части, которые могут использовать таблицы независимо друг от друга.

В теории баз данных это атрибуты, которые хранят единственное значение и не являются ни списком, ни множеством значений. 
Иными словами, это такие данные, разделение которых на составляющие приводит к потере их смысла с точки зрения решаемой задачи. 
Например, если атрибут «Цена» содержит значение 15, то попытка разделить его на 1 и 5 приведет к полной бессмыслице.
Данные, не являющиеся атомарными, называются составными.

* **Правило 2**: все строки должны быть различными (у товара должен быть свой уникальный номер, чтобы не было дублей, обычно называется артикулом (первичный ключ)).

### Вторая нормальная форма
* **Правило 3**: любое поле таблицы не входящее в состав первичного ключа функционально полно зависит от первичного ключа. 

### Третья нормальная форма
* **Правило 4**: таблица соответствует данной форме, если она удовлетворяет всем предыдущим правилам и любой её не ключевой аттрибут функционально зависит только от первичного ключа.

По сути, главная таблица имеет значения ссылающиеся на другие таблицы:

![img](https://github.com/SergiaS/programmer-tech-wiki/blob/master/src/main/resources/img/sql_nf3.png?raw=true)



## JOIN'ы
* [Visual Representation of SQL Joins](https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins)
* [Приклади з малюнку на coderoad.ru](https://coderoad.ru/5706437/В-чем-разница-между-INNER-JOIN-LEFT-JOIN-RIGHT-JOIN-и-FULL-JOIN#28719292)
  * `INNER JOIN`: возвращает строки, когда есть совпадение в обеих таблицах.
  * `LEFT JOIN`: возвращает все строки из левой таблицы, даже если нет совпадений в правой таблице.
  * `RIGHT JOIN`: возвращает все строки из правой таблицы, даже если нет совпадений в левой таблице.
  * `FULL JOIN`: объединяет результаты как левого, так и правого внешних джоинов.
  * <u>**Объединяемая таблица будет содержать все записи из обеих таблиц и заполнять NULL'ами для отсутствующих совпадений с любой стороны.**</u> 

* Ассоциация с диаграммой Венна.

> Ключевое слово `OUTER` можно опускать. Запись `LEFT JOIN` идентична `LEFT OUTER JOIN`.

![img](https://raw.githubusercontent.com/SergiaS/programmer-tech-wiki/master/src/main/resources/img/SQL_JOIN.png)

**Зачем использовать SQL JOIN?**

Используйте **SQL** `JOIN` всякий раз, когда к нескольким таблицам необходимо обращаться через оператор **SQL** `SELECT`и 
никакие результаты не должны возвращаться, если между `JOIN`'ed таблицами нет совпадения.

* [Объяснение SQL объединений JOIN: LEFT/RIGHT/INNER/OUTER](http://www.skillz.ru/dev/php/article-Obyasnenie_SQL_obedinenii_JOIN_INNER_OUTER.html)
  * `OUTER JOIN` - Такое объединение вернет данные из обеих таблиц (совпадающие по условию объединения) ПЛЮС дополнит
    выборку оставшимися данными из внешней таблицы, которые по условию не подходят, заполнив недостающие данные значением `NULL`.

  * `INNER JOIN` - Внутреннее объединение `INNER JOIN` (синоним `JOIN`, ключевое слово `INNER` можно опустить).
    Выбираются только совпадающие данные из объединяемых таблиц.

  * `LEFT JOIN` - говорит, что "внешней" таблицей будет указанная в запросе таблица слева, (в примере это таблица users):
      ```sql
      SELECT u.id, u.name, d.name AS d_name
      FROM users u
      LEFT OUTER JOIN departments d ON u.d_id = d.id
      ```
    Результат: получаем полный список пользователей и сопоставленные департаменты:
      ```sql
      id      name          d_name
      --      --------      ---------
      1       Владимир      Сейлз
      2       Антон         Поддержка
      3       Александр     NULL
      4       Борис         Поддержка
      5       Юрий          Логистика
      ```
  * `RIGHT JOIN` - аналогично `LEFT JOIN`, только главная таблица указанная в запросе справа.





***

Стандарты SQL определяют 4 уровня изолированности:
* READ_UNCOMMITTED
* READ_COMMITTED
* REPEATABLE_READ
* SERIALIZABLE




## DISTINCT
Устраняет дублирующие записи - будут отображены только уникальные записи.
```postgresql
SELECT DISTINCT u
FROM users u
RIGHT JOIN user_roles ur ON u.id = ur.user_id
WHERE u.id=100001
```


## Декартово произведения (Декартово произведение множеств)
Проблемой Декартова произведения: 
для каждого уникального пользователя количество записей в результирующей таблице будет повторяться столько раз, 
сколько у него было ролей.

Чтобы этого избежать, отдельным запросом получим из базы все роли, и сгруппируем их в `Map` по `userId`, 
где ключом будет являться `userId`, а значением — набор ролей пользователя. 
После чего пройдемся по всем пользователям, загруженным из базы, и установим каждому его роли.


## User with his Roles
ЗАДАЧА: достать юзера с его ролями. Дано две таблицы `user` и `user_roles`. У одного пользователя может быть пара ролей.

Чтобы рез-т не выводился отдельно для каждой роли на юзера, нужно использовать агрегированную функцию и сгруппировать по `id`:
```postgresql
SELECT u.*, string_agg(r.role, ',') AS roles
FROM users u
JOIN user_roles r ON u.id=r.user_id
GROUP BY u.id
```


