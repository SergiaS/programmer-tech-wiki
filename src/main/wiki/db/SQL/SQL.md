# SQL

## [Нормальные формы 1-3](https://www.youtube.com/watch?v=_GQaTW6N1GY)

### Первая нормальная форма
* **Правило 1**: все элементы внутри ячеек должны быть атомарными (т.е. у каждого столбца своё предназначение - бренд, цвет..., а не 'TV Sony KX40').
Элемент является атомарным, если его нельзя разделить на части, которые могут использовать таблицы независимо друг от друга.

В теории баз данных это атрибуты, которые хранят единственное значение и не являются ни списком, ни множеством значений. 
Иными словами, это такие данные, разделение которых на составляющие приводит к потере их смысла с точки зрения решаемой задачи. 
Например, если атрибут «Цена» содержит значение 15, то попытка разделить его на 1 и 5 приведет к полной бессмыслице.
Данные, не являющиеся атомарными, называются составными.

* **Правило 2**: все строки должны быть различными (у товара должен быть свой уникальный номер, чтобы не было дублей, обычно называется артикулом (первичный ключ)).

### Вторая нормальная форма
* **Правило 3**: любое поле таблицы не входящее в состав первичного ключа функционально полно зависит от первичного ключа. 

### Третья нормальная форма
* **Правило 4**: таблица соответствует данной форме, если она удовлетворяет всем предыдущим правилам и любой её не ключевой аттрибут функционально зависит только от первичного ключа.

По сути, главная таблица имеет значения ссылающиеся на другие таблицы:

![img](https://github.com/SergiaS/programmer-tech-wiki/blob/master/src/main/resources/img/sql_nf3.png?raw=true)




## JOIN'ы
* Ассоциация с диаграммой Венна.
* [Объяснение SQL объединений JOIN: LEFT/RIGHT/INNER/OUTER](http://www.skillz.ru/dev/php/article-Obyasnenie_SQL_obedinenii_JOIN_INNER_OUTER.html)
* `OUTER JOIN` - Такое объединение вернет данные из обеих таблиц (совпадающие по условию объединения) ПЛЮС дополнит 
  выборку оставшимися данными из внешней таблицы, которые по условию не подходят, заполнив недостающие данные значением `NULL`.

* `INNER JOIN` - Внутреннее объединение `INNER JOIN` (синоним `JOIN`, ключевое слово `INNER` можно опустить).
Выбираются только совпадающие данные из объединяемых таблиц.

* `LEFT JOIN` - говорит, что "внешней" таблицей будет указанная в запросе таблица слева, (в примере это таблица users):
    ```sql
    SELECT u.id, u.name, d.name AS d_name
    FROM users u
    LEFT OUTER JOIN departments d ON u.d_id = d.id
    ```
    Результат: получаем полный список пользователей и сопоставленные департаменты:
    ```sql
    id      name          d_name
    --      --------      ---------
    1       Владимир      Сейлз
    2       Антон         Поддержка
    3       Александр     NULL
    4       Борис         Поддержка
    5       Юрий          Логистика
    ```
  Ключевое слово `OUTER` можно опускать. Запись `LEFT JOIN` идентична `LEFT OUTER JOIN`.

* `RIGHT JOIN` - аналогично `LEFT JOIN`, только главная таблица указанная в запросе справа.


***

Стандарты SQL определяют 4 уровня изолированности:
* READ_UNCOMMITTED
* READ_COMMITTED
* REPEATABLE_READ
* SERIALIZABLE




## DISTINCT
Устраняет дублирующие записи - будут отображены только уникальные записи.
```postgresql
SELECT DISTINCT u
FROM users u
RIGHT JOIN user_roles ur ON u.id = ur.user_id
WHERE u.id=100001
```


## Декартово произведения (Декартово произведение множеств)
Проблемой Декартова произведения: 
для каждого уникального пользователя количество записей в результирующей таблице будет повторяться столько раз, 
сколько у него было ролей.

Чтобы этого избежать, отдельным запросом получим из базы все роли, и сгруппируем их в `Map` по `userId`, 
где ключом будет являться `userId`, а значением — набор ролей пользователя. 
После чего пройдемся по всем пользователям, загруженным из базы, и установим каждому его роли.


## User with his Roles
ЗАДАЧА: достать юзера с его ролями. Дано две таблицы `user` и `user_roles`. У одного пользователя может быть пара ролей.

Чтобы рез-т не выводился отдельно для каждой роли на юзера, нужно использовать агрегированную функцию и сгруппировать по `id`:
```postgresql
SELECT u.*, string_agg(r.role, ',') AS roles
FROM users u
JOIN user_roles r ON u.id=r.user_id
GROUP BY u.id
```


