# Python 3 introduce
Некоторые особенности Python для подсказки:

* Python НЕ похож на JAVA.

* Python 3 не совместим с прошлыми версиями.

* **Здесь имеют значения отступы!**
  Вложенные инструкции объединяются в блоки по величине отступов. 
  Отступ может быть любым, главное, чтобы в пределах одного вложенного блока отступ был одинаков.

* Принцип вызова некоторых методов отличается от JAVA.
  Если в JAVA узнать длину массива будет `arr.length`, в Python - `len(arr)`.

* Допустимо записывать одну инструкцию в нескольких строках. Достаточно ее заключить в пару круглых, квадратных или фигурных скобок:
  ```python
  if (a == 1 and b == 2 and
      c == 3 and d == 4):  # Не забываем про двоеточие
        print('spam' * 3)
  ```

* Названия методов советуют делать в LowerCase letters.

* В Python нет инкремента/декремента типа `++/--`. нужно писать типа `count += 1`.

* Метод указывается зарезервированным словом `def`.

* Необязательно указывать метинфу:
    ```python
    class Solution:
        def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
    ```
    можно так:
    ```python
    class Solution:
        def findMaxConsecutiveOnes(self, nums:):
    ```

* Переменные объявляются без указания типа:
    ```python
    count = 0
    name = "Bob"
    ```
  
* Тернарный оператор.
  Возврат `1` если равно чему-то из условия `(n == 1 or n == 2)` в противном случае - `0`.
  ```python
  return 1 if (n == 1 or n == 2) else 0
  ```
  ```python
  # обычная форма записи через if
  if n == 1 or n == 2:
    return 1
  else:
    return 0
  ```
  
* Сокращенная конструкция if/else - тот же тернерный оператор. Вместо обычной:
  ```python
  if X:
      A = Y
  else:
      A = Z
  ```
  можно писать сокращенный аналог:
  ```python
  A = Y if X else Z
  ```

* Конец строки является концом инструкции (точка с запятой `;` не требуется).

* В конструкции `if-else`, если в else нужен ещё один `if` - нужно писать `elif`.

* Логические операторы: `X and Y`, `X or Y`, `not X`.

* Пример чтения двухмерного массива:
```python
tests = [
    [4,2,5,7],
    [2,3],
    [9,4,6,8,7,5,2,3]
]

print([test for test in tests])
```

## Массивы
[array](https://docs.python.org/3/library/array.html)
|| [Модуль array](https://pythonworld.ru/moduli/modul-array-massivy-v-python.html) 

Python не имеет ленивой инициализации (как в Java, где при создании все элементы `int[]` заполнены `0`) - значения индексов массива нужно устанавливать самому.

Данный пример как бы говорит создай массив с `9`-ью элементами и инициализируй их `0`-ями:
  ```python
  # Пример создания массива с нужной длиной
  arr = [0] * 9
  ```

<hr>

### Метод `append`
Добавляет новый элемент к массиву:
```python
arr = [0] * 2
print(arr) # [0, 0]
arr.append(1)
print(arr) # [0, 0, 1]
```

<hr>

### Метод `extend`
Добавляет массив в другой массив:
```python
arr = [0] * 2
print(arr) # [0, 0]
arr.extend([3, 3, 3])
print(arr) # [0, 0, 3, 3, 3]
```

<hr>

### Метод `insert`
Вставляет объект на указанную позицию в массиве:
```python
arr = [0] * 3
print(arr)
arr.insert(1, 9)
print(arr)
```

<hr>

### Аналог метода `substring`
Такого метода нет, но есть специальный синтаксис:
```python
s = "BobbySinger"
print(s[0:6]) # BobbyS
```
Есть нужно выводить каждый `n` символ:
```python
s = "BobbySinger"
print(s[::6]) # Bi
```

<hr>

### Аналог метода `indexOf`
Чтобы узнать индекс символа используется метод `index`.
Он возвращает номер индекса если символ есть, если нет - ОШИБКА!
Поэтому сначало нужно проверять есть ли данный символ в строке, и если есть - узнавать его символ.
Отлично подойдёт тернарный оператор:
```python
email = "fg.r.u.uzj+o.pw@kziczvh.com"
plus_idx = email.index("+") if "+" in email else -1
```
Либо сразу обрезать строку по символ если он там есть:
```python
if "+" in local: 
  local = local[:local.index("+")]
```

<hr>


